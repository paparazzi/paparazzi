extern crate bindgen;
extern crate cbindgen;

use std::env;
use std::path::{Path, PathBuf};
use std::io::{BufReader, BufWriter, BufRead, Write};
use std::fs::File;

pub fn generate_bindings() {
    let module_name = env::var("CARGO_PKG_NAME").unwrap();
    
    //
    // Bindings for Rust
    //
    let pprz_dir = env::var("PAPARAZZI_SRC").expect("PAPARAZZI_SRC not present");
    let generated_dir = env::var("AC_GENERATED").expect("AC_GENERATED not present");
    let pprz_path = Path::new(&pprz_dir);
    let path_include = pprz_path.join("sw/include");
    let path_airborne = pprz_path.join("sw/airborne/");

    // Write the bindings to the $OUT_DIR/bindings.rs file.
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());

    //
    // Parse generated airframe.h and remove any includes to make live easier for bindgen
    //
    let file_path_in = generated_dir.clone() + "/airframe.h";
    let path_in = Path::new(&file_path_in);
    let airframe_h = BufReader::new(File::open(&path_in).unwrap());
    let file_path_out = generated_dir.clone() + "/airframe_no_includes.h";
    let path_out = Path::new(&file_path_out);
    let mut airframe_no_includes_h = BufWriter::new(File::create(&path_out).unwrap());

    for line in airframe_h.lines() {
        if let Ok(line) = line {
            if line.contains("#include") {
                airframe_no_includes_h.write("// ".as_bytes()).unwrap();
            }
            airframe_no_includes_h.write(line.as_bytes()).unwrap();
            airframe_no_includes_h.write("\n".as_bytes()).unwrap();
        }
    }
    airframe_no_includes_h.flush().unwrap();

    // Generate airframe.rs
    let bindings_airframe = bindgen::Builder::default()
        .header(generated_dir.clone() + "/airframe_no_includes.h")
        .clang_arg(String::from("-I") + path_include.to_str().expect("path include problem"))
        .clang_arg(String::from("-I") + path_airborne.to_str().expect("path airborne problem"))
        .clang_arg(String::from("-I") + &generated_dir)
        .layout_tests(false)
        .use_core()
        .generate()
        .expect("Unable to generate airframe bindings");

    bindings_airframe
        .write_to_file(out_path.join("airframe.rs"))
        .expect("Couldn't write airframe bindings!");
/*
    // Generate state.rs
    let bindings_state = bindgen::Builder::default()
        .header(path_airborne.to_str().unwrap().to_owned() + "/state.h")
        .clang_arg(String::from("-I") + path_include.to_str().expect("path include problem"))
        .clang_arg(String::from("-I") + path_airborne.to_str().expect("path airborne problem"))
        .clang_arg(String::from("-I") + &generated_dir)
        .layout_tests(false)
        .use_core()
        .ignore_functions()
        .generate()
        .expect("Unable to generate state bindings");

    bindings_state
        .write_to_file(out_path.join("state.rs"))
        .expect("Couldn't write state bindings!");
        */

    //
    // Bindings for paparazzi using cbindgen
    //
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let builder_include_guard = String::from("RUST_") + &module_name.to_uppercase() + "_H";
    let bindings_name = String::from(module_name) + ".h";

    cbindgen::Builder::new()
        // # An optional string of text to output at the beginning of the generated file
        .with_header("/* Text to put at the beginning of the generated file. Probably a license. */")
        // # An optional string of text to output at the end of the generated file
        .with_trailer("/* Text to put at the end of the generated file */")
        // # An optional string of text to output between major sections of the generated
        // # file as a warning against manual editing
        .with_autogen_warning("/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */")
        // # An optional name to use as an include guard
        .with_include_guard(builder_include_guard)
        // # The language to output bindings in
        .with_language(cbindgen::Language::C)
        // # Whether to parse dependent crates and include their types in the generated
        // # bindings
        .with_parse_deps(false)
        // # A black list of crate names that are not allowed to be parsed
        .with_parse_exclude(&vec!["libc"])
        .with_crate(crate_dir)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(bindings_name);

}
